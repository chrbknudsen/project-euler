---
title: "Euler 144"
output: html_document
date: '2023-05-27'
params:
  done: F
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


En celle med ligningen 4x^2 + y^2 = 100

Hvis lyset rammer -0.01 <= x <= 0.01 - så undslipper det.

lysest starter ved 0.0, 10.1, og rammer spejlet i positionen
1.4, -9.6

Lyset reflekteres, således at indfaldsvinklen i forhold til normalen på hældningen
af spejlet er den samme som udfaldsvinklen

Hældningen/tangenten m er for alle punkter m = -4x/y

```{r}
m <- function(x,y){
  -4*x/y
}
```


Jeg har en vektor, der er karakteriseret ved et start og et slutpunkt. 

Jeg har en anden vektor hvor jeg kender hældningen - fordi jeg kender slutpunktet.

så skal vi have beregnet vinklen mellem de to vektorer. 

```{r}
points2vector <- function(x1,y1,x2,y2){
  c(x2-x1,y2-y1)
}
```

```{r}
vektor1 <- points2vector(0,10.1,1.4,-9.6)

```
Vi skal også bruge prikproduktet af de to vektorer.

Og størrelsen af de to vektorer.

Så kan vi beregne vinklen ved:
cos(vinkel) = prikprodukt divideret med produktet af størrelserne.

Det er indfaldsvinklen. Nu har vi så en indfaldsvektor, og en indfaldsvinkel.
Så skal vi have beregnet udfaldsvinklen, og finde ud af hvordan vi finder 
slutpunktet for det næste segment.


Vi har nok også lyst til at visualisere...


Så når det rammer 8 i 1.4, -9.6, er hældningen


Hvordan finder jeg normalen til den?



# Definerer vektoren for den indkommende lysstråle og normalvektoren
v <- c(1, 2, 3) # Eksempel på en indkommende vektor
n <- c(0, 1, 0) # Eksempel på normalvektoren til overfladen

# Normaliserer normalvektoren, hvis den ikke allerede er en enhedsvektor
n <- n / sqrt(sum(n^2))

# Beregner den reflekterede vektor
r <- v - 2 * sum(v * n) * n

# Udskriver den reflekterede vektor
r


```{r}
positioner <- data.frame(x = c(0,1.4), y = c(10.1,-9.6))


positioner

```

```{r}
x <- 3
sqrt(100-4*x^2)
```
```{r}
a <- 5
b <- 10
theta <- seq(0,2*pi,length.out = 100)
x <- a*cos(theta)
y <- b * sin(theta)
ellipse_df <- data.frame(x,y)
ellipse_df %>% 
  ggplot(aes(x,y))+
  geom_path() +
  coord_fixed() +
  geom_path(positioner, mapping = aes(x,y))
```

Så skal vi have beregnet det næste punkt. 

```{r}
positioner
```

Vi skal bruge normalvektoren til tangenten til elipsen.

Hældningen på den tangent kender vi. Så finder vi vektoren ved

```{r}
normalen <- function(x,y){
  
}
punktet er:
(1.4, -9.6)

hældningen er

m(1.4, -9.6) # 0.5833333

det nye punkt er derfor (2.4, -9.6+0.5833333) 
og derfor er vektoren i reflektion altid (1, hældningen)
Den har to normalvektorer.

```

En særlig udfordring er selvfølgelig at finde ud af hvilken af de to 
normalvektorer der skal bruges...


```{r}

```

