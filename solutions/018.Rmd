---
title: "Euler 18"
format: html
date: '2018-02-12'
---



Given a triangle of this shape
```text
   3
  7 4
 2 4 6
8 5 9 3
```

Taking a route from top to bottom, moving to adjacent numbers in the row below, 
and adding the numbers on the path - what is the maximum sum we can get?

Rather than going from top to bottom, we can go from bottom to top.
If we get to "4" in the third row, we should chose 9 - because that will maximise
the sum regardles of the path that led us to the 4. 

So we collapse the larger triangle from bottom to top.

Having figured this out, two steps remain. Store the triangle in some datastructure.
Write a function that take the two last rows, and collapse them into a new row with the maximum possible result. 
Update the triangle, and continue until
only the top row is left. Theres your answer.


Let us write at function that collapses two rows into one:

```{r}
collapse <- function(a, b ){
  output <- numeric()
  for(i in 1:length(a)){
    output[i] <- max(a[i]+b[i], a[i]+b[i+1])
  }
  output
  }
```


Import the data into something we can work with:

```{r echo = FALSE}
triangle <- "75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23"



```

```{r}
triangle <- str_split(triangle, "\\n") %>% unlist() %>% 
  str_split(" ") %>% 
  lapply(as.numeric)
```

Throw everything together:
```{r}
lowest <- length(triangle)
while(lowest > 2){
  lowest <- length(triangle)
  triangle[[lowest - 1]] <- collapse(triangle[[lowest-1]], triangle[[lowest]])
  triangle[[lowest]] <- NULL  
}
answer <- unlist(triangle)
```

